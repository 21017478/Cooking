const fs = require('fs');
const path = require('path');

const SOURCE_FILES = [
    'premium-meals-detailed.md',
    'detailed-recipes.md',
    'tier2-proteins-detailed.md',
    'tier2-pork-detailed.md',
    'tier3-4-sides-detailed.md',
    'vegetarian-mains.md',
    'breakfast-recipes.md',
    'dessert-recipes.md'
];

const OUTPUT_FILE = 'recipes.js';

function main() {
    const allRecipes = [];

    SOURCE_FILES.forEach(file => {
        const filePath = path.join(__dirname, '..', 'data', file);
        if (!fs.existsSync(filePath)) {
            console.warn(`Warning: File not found: ${file}`);
            return;
        }

        const content = fs.readFileSync(filePath, 'utf8');
        const recipes = parseFile(content, file);
        allRecipes.push(...recipes);
    });

    const fileContent = `// This file is AUTO-GENERATED by scripts/build-recipes.js
// DO NOT EDIT THIS FILE DIRECTLY. Edit the Markdown files instead.

const recipes = ${JSON.stringify(allRecipes, null, 4)};
`;

    fs.writeFileSync(path.join(__dirname, '..', '..', OUTPUT_FILE), fileContent);
    console.log(`Successfully generated ${OUTPUT_FILE} with ${allRecipes.length} recipes.`);
}

function parseFile(content, filename) {
    // Split by "## " header ONLY (H2)
    const chunks = content.split(/^#{2} /m).slice(1);

    console.log(`Processing ${filename}: Found ${chunks.length} recipe chunks`);

    return chunks.map((chunk, index) => {
        const recipe = parseRecipe(chunk, filename);
        if (recipe && recipe.ingredients && recipe.ingredients.length > 0) {
            console.log(`  Recipe ${index + 1}: ${recipe.name} (ID: ${recipe.id})`);
            return recipe;
        }
        if (recipe) {
            console.log(`  [Skipping] Invalid/Header '${recipe.name}' (No ingredients found)`);
        }
        return null;
    }).filter(r => r !== null);
}

function parseRecipe(chunk, filename) {
    const lines = chunk.split('\n');
    const titleLine = lines[0].trim();

    let id = '';
    let name = '';
    let emoji = 'ü•ò';

    const titleMatch = titleLine.match(/(?:(.*?)\s+)?(?:PREMIUM\s+)?(?:RECIPE|MEAL)\s*([A-Za-z0-9-]+):\s*(.*)/i);

    if (titleMatch) {
        const capturedEmoji = titleMatch[1] ? titleMatch[1].trim() : '';
        if (capturedEmoji && capturedEmoji.length < 5) emoji = capturedEmoji;

        id = titleMatch[2].trim();
        name = titleMatch[3].trim();
    } else {
        name = titleLine;
        id = name.replace(/[^a-z0-9]/gi, '-').toLowerCase();
    }

    id = id.toLowerCase();

    let category = 'Main';
    let type = 'Standard';

    const metaLine = lines.find(l => l.includes('**Category:**'));
    if (metaLine) {
        const catMatch = metaLine.match(/\*\*Category:\*\*\s*(.*?)\s*\|/);
        const typeMatch = metaLine.match(/\*\*Type:\*\*\s*(.*)/);
        if (catMatch) category = catMatch[1].trim();
        if (typeMatch) type = typeMatch[1].trim();
    } else if (filename.includes('premium')) {
        type = 'Premium';
        category = 'Premium';
    } else if (filename.includes('vegetarian')) {
        category = 'Vegetarian';
    } else if (filename.includes('breakfast')) {
        category = 'Breakfast';
    } else if (filename.includes('dessert')) {
        category = 'Dessert';
    }

    let prepTime = 'N/A';
    let cookTime = 'N/A';
    let totalTime = 'N/A';

    const timeSection = extractSection(chunk, 'Time Requirements');
    if (timeSection) {
        const prepMatch = timeSection.match(/\*\*Prep Time:\*\*\s*(.*)/);
        const cookMatch = timeSection.match(/\*\*Cook Time:\*\*\s*(.*)/);
        const totalMatch = timeSection.match(/\*\*Total Time:\*\*\s*(.*)/);

        if (prepMatch) prepTime = prepMatch[1].trim();
        if (cookMatch) cookTime = cookMatch[1].trim();
        if (totalMatch) totalTime = totalMatch[1].trim();
    }

    const htmlContent = convertMarkdownToHtml(chunk);
    const description = extractDescription(chunk, name, category);
    const sections = extractSections(chunk);
    const ingredients = extractAllIngredients(chunk);



    return {
        id,
        name,
        category: category.toLowerCase(),
        type: type.toLowerCase(),
        isPremium: type.toLowerCase().includes('premium'),
        image: emoji,
        description,
        prepTime,
        cookTime,
        totalTime,
        ingredients,
        content: htmlContent, // Keep legacy content for fallback
        sections // New Structured Content
    };
}

function extractAllIngredients(chunk) {
    const allIngredients = [];

    // 1. Component Logic (Priority)
    const componentRegex = /#{3}\s+COMPONENT\s+\d*[:\s]*(.*?)(?=\n|$)/gi;
    let match;
    const components = [];
    while ((match = componentRegex.exec(chunk)) !== null) {
        components.push({
            name: match[1].trim(),
            startIndex: match.index
        });
    }

    if (components.length > 0) {
        // Multi-component Processing
        for (let i = 0; i < components.length; i++) {
            const start = components[i].startIndex;
            const end = (i < components.length - 1) ? components[i + 1].startIndex : chunk.length;
            const compChunk = chunk.slice(start, end);

            const compIngText = extractSection(compChunk, 'Ingredients');
            if (compIngText) {
                // Add parsing logic here
                const items = parseListItems(compIngText);
                allIngredients.push(...items);
            }
        }
    } else {
        // Single Recipe Processing
        const ingText = extractSection(chunk, 'Ingredients');
        if (ingText) {
            allIngredients.push(...parseListItems(ingText));
        } else {
            // Fallback: simple extraction without complex lookahead
            const headerMatch = chunk.match(/(?:#{2,4}|\*\*)\s*Ingredients/i);
            if (headerMatch) {
                const startIndex = headerMatch.index + headerMatch[0].length;
                const remaining = chunk.substring(startIndex);
                // Stop at next header (start of line)
                const nextHeaderMatch = remaining.match(/\n\s*(?:#{2,4}|\*{2,})/);
                const sectionContent = nextHeaderMatch ? remaining.substring(0, nextHeaderMatch.index) : remaining;
                if (sectionContent.trim().length > 0) {
                    // console.log(`[Fallback] Extracted ingredients for recipe from raw content.`);
                    allIngredients.push(...parseListItems(sectionContent));
                }
            }
        }
    }

    return [...new Set(allIngredients)]; // Dedupe strings exactly matching
}

function parseListItems(markdownText) {
    const items = [];
    const lines = markdownText.split('\n');



    for (const line of lines) {
        const trimmed = line.trim();

        // Match list items: - item, * item, 1. item
        if (trimmed.startsWith('- ') || trimmed.startsWith('* ') || /^\d+\./.test(trimmed)) {
            // Remove the marker
            let item = trimmed.replace(/^[-*]\s+/, '').replace(/^\d+\.\s+/, '').trim();
            // Remove any markdown bold/italic
            item = item.replace(/\*\*(.*?)\*\*/g, '$1').replace(/\*(.*?)\*/g, '$1').replace(/__(.*?)__/g, '$1').replace(/_(.*?)_/g, '$1');
            // Remove [OPTIONAL] tags or similar if needed, keeping simple for now
            if (item) items.push(item);
        }
    }
    return items;
}

function extractDescription(markdown, name, category) {
    const whySpecial = extractSection(markdown, 'Why This Meal is Special') ||
        extractSection(markdown, 'Why Vacuum Sealing Makes It Special');

    if (whySpecial) {
        const firstLine = whySpecial.split('\n').find(l => l.trim().length > 20);
        if (firstLine) {
            let desc = firstLine.replace(/\*\*/g, '').replace(/^[#\-\*\s]+/, '').trim();
            if (desc.length > 120) desc = desc.substring(0, 117) + '...';
            return desc;
        }
    }

    return `Vacuum-sealed ${name || 'recipe'} for optimal freshness.`;
}

function extractSection(markdown, sectionName) {
    const majorSections = [
        'Ingredients', 'Spice Ratios',
        'Instructions', 'Step-by-Step Instructions',
        'Equipment', 'Equipment Needed',
        'Storage', 'Storage Instructions',
        'Pro Tips',
        'Time Requirements',
        'Safety', 'Safety Checks',
        'Nutrition', 'Nutrition Information',
        'Why This Meal is Special', 'Why Vacuum Sealing Makes It Special',
        'Pairs Well With', 'Beverage Pairing', 'Wine Pairing',
        'Plating', 'Complete Meal Assembly', 'Assembly',
        'Chef\'s Critique',
        'Component'
    ];

    // Lookahead pattern: Next Major Section header OR End of String
    // We allow ### or ** as header markers
    const lookahead = `(?=(?:\\n\\s*(?:#{2,4}|\\*\\*)\\s*(?:${majorSections.join('|')}))|$)`;

    // Main Pattern: Header (### or **) + sectionName + Content + Lookahead
    const regex = new RegExp(`(?:#{2,4}|\\*\\*)\\s*${sectionName}[:\\s]*(?:\\*\\*)?([\\s\\S]*?)${lookahead}`, 'i');

    const match = markdown.match(regex);


    return match ? match[1].trim() : null;
}

function extractSections(chunk) {
    const sections = {
        essentials: '',
        masterclass: '',
        chefs_table: '',
        nutrition: ''
    };

    // 1. Common Global Sections
    const whySpecial = extractSection(chunk, 'Why This Meal is Special') || extractSection(chunk, 'Why Vacuum Sealing Makes It Special');
    const timeReq = extractSection(chunk, 'Time Requirements');
    const safety = extractSection(chunk, 'Safety') || extractSection(chunk, 'Safety Checks');
    const nutrition = extractSection(chunk, 'Nutrition') || extractSection(chunk, 'Nutrition Information');
    const proTips = extractSection(chunk, 'Pro Tips');
    const storage = extractSection(chunk, 'Storage') || extractSection(chunk, 'Storage Instructions');
    const pairsWell = extractSection(chunk, 'Pairs Well With') || extractSection(chunk, 'Beverage Pairing') || extractSection(chunk, 'Wine Pairing');
    const critique = extractSection(chunk, 'Chef\'s Critique') || extractSection(chunk, 'Chef\'s Critique & Secrets');
    const plating = extractSection(chunk, 'Plating') || extractSection(chunk, 'Complete Meal Assembly') || extractSection(chunk, 'Assembly');

    // 2. Component Logic
    const componentRegex = /#{3}\s+COMPONENT\s+\d*[:\s]*(.*?)(?=\n|$)/gi;
    let match;
    const components = [];
    while ((match = componentRegex.exec(chunk)) !== null) {
        components.push({
            name: match[1].trim(),
            startIndex: match.index,
            fullMatch: match[0]
        });
    }

    let ingredientsHtml = '';
    let instructionsHtml = '';
    let equipmentsHtml = '';

    if (components.length > 0) {
        // Multi-component Processing
        for (let i = 0; i < components.length; i++) {
            const start = components[i].startIndex;
            const end = (i < components.length - 1) ? components[i + 1].startIndex : chunk.length;
            const compChunk = chunk.slice(start, end);
            const compName = components[i].name || `Component ${i + 1}`;

            const compIng = extractSection(compChunk, 'Ingredients');
            const compInstr = extractSection(compChunk, 'Instructions') || extractSection(compChunk, 'Step-by-Step Instructions');
            const compEquip = extractSection(compChunk, 'Equipment') || extractSection(compChunk, 'Equipment Needed');

            if (compIng) ingredientsHtml += `<h4>${compName}</h4>\n${convertMarkdownToHtml(compIng)}`;
            if (compInstr) instructionsHtml += `<h4>${compName}</h4>\n${convertMarkdownToHtml(compInstr)}`;
            if (compEquip) equipmentsHtml += `<h4>${compName}</h4>\n${convertMarkdownToHtml(compEquip)}`;
        }
    } else {
        // Single Recipe Processing
        const ing = extractSection(chunk, 'Ingredients');
        const spice = extractSection(chunk, 'Spice Ratios');
        const instr = extractSection(chunk, 'Instructions') || extractSection(chunk, 'Step-by-Step Instructions');
        const equip = extractSection(chunk, 'Equipment') || extractSection(chunk, 'Equipment Needed');

        if (ing) ingredientsHtml += `<h3>Ingredients</h3>\n${convertMarkdownToHtml(ing)}`;
        if (spice) ingredientsHtml += `<h3>Spice Ratios</h3>\n<div class="spice-ratios">${convertMarkdownToHtml(spice)}</div>`;
        if (equip) equipmentsHtml += `<h3>Equipment Needed</h3>\n${convertMarkdownToHtml(equip)}`;
        if (instr) instructionsHtml += `<h3>Instructions</h3>\n${convertMarkdownToHtml(instr)}`;
    }

    // 3. Assemble Essentials
    if (timeReq) sections.essentials += `<h3>Time Requirements</h3>\n${convertMarkdownToHtml(timeReq)}`;

    // Equipment
    if (components.length > 0 && equipmentsHtml) sections.essentials += `<h3>Equipment Needed</h3>\n${equipmentsHtml}`;
    else if (equipmentsHtml) sections.essentials += equipmentsHtml;

    // Ingredients
    if (components.length > 0 && ingredientsHtml) sections.essentials += `<h3>Ingredients</h3>\n${ingredientsHtml}`;
    else if (ingredientsHtml) sections.essentials += ingredientsHtml;

    // Instructions
    if (components.length > 0 && instructionsHtml) sections.essentials += `<h3>Instructions</h3>\n${instructionsHtml}`;
    else if (instructionsHtml) sections.essentials += instructionsHtml;


    // 4. Assemble Masterclass
    sections.masterclass += whySpecial ?
        `<h3>Why This Meal is Special</h3>\n${convertMarkdownToHtml(whySpecial)}` :
        `<p>Experience professional quality cooking at home with this vacuum sealed recipe.</p>`;

    if (safety) sections.masterclass += `<div class="safety-warning"><h3>‚ö†Ô∏è Safety First</h3>\n${convertMarkdownToHtml(safety)}</div>`;
    if (proTips) sections.masterclass += `<h3>Pro Tips</h3>\n${convertMarkdownToHtml(proTips)}`;
    if (storage) sections.masterclass += `<h3>Storage Instructions</h3>\n${convertMarkdownToHtml(storage)}`;

    // 5. Assemble Chef's Table
    if (plating) sections.chefs_table += `<h3>Plating & Assembly</h3>\n${convertMarkdownToHtml(plating)}`;
    if (pairsWell) sections.chefs_table += `<h3>Pairs Well With</h3>\n${convertMarkdownToHtml(pairsWell)}`;
    if (critique) sections.chefs_table += `<div class="chef-critique"><h3>üë®‚Äçüç≥ Chef's Critique</h3>\n${convertMarkdownToHtml(critique)}</div>`;

    // 6. Assemble Nutrition
    if (nutrition) sections.nutrition += `<h3>Nutrition Information</h3>\n${convertMarkdownToHtml(nutrition)}`;

    return sections;
}

function convertMarkdownToHtml(markdown) {
    return processLinesToHtml(markdown);
}

function processLinesToHtml(markdown) {
    const lines = markdown.split('\n');
    let html = '';
    let inList = false;
    let listType = null;

    lines.forEach((line, index) => {
        line = line.trim();

        // Skip Title (first line is title)
        if (index === 0) return;

        if (line.startsWith('**Category:**')) return;
        if (line === '---') return;

        if (line.startsWith('#### ') || line.startsWith('### ')) {
            if (inList) { html += `</${listType}>\n`; inList = false; }
            // Remove hashes and trim
            const title = line.replace(/^#+\s+/, '');
            html += `<h3>${title}</h3>\n`;
            return;
        }

        const isUl = line.startsWith('- ');
        const isOl = /^\d+\.\s/.test(line);

        if (isUl || isOl) {
            const currentType = isUl ? 'ul' : 'ol';

            if (!inList) {
                inList = true;
                listType = currentType;
                html += `<${listType}>\n`;
            } else if (listType !== currentType) {
                html += `</${listType}>\n<${currentType}>\n`;
                listType = currentType;
            }

            const content = line.replace(/^(- |\d+\.\s)/, '');
            html += `  <li>${formatInline(content)}</li>\n`;
        } else {
            if (inList) {
                html += `</${listType}>\n`;
                inList = false;
            }

            if (line.length > 0) {
                if (line.startsWith('**') && line.endsWith('**') && line.length < 50) {
                    html += `<h4>${line.replace(/\*\*/g, '')}</h4>\n`;
                } else {
                    html += `<p>${formatInline(line)}</p>\n`;
                }
            }
        }
    });

    if (inList) html += `</${listType}>\n`;

    return html;
}

function formatInline(text) {
    text = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
    text = text.replace(/\*(.*?)\*/g, '<em>$1</em>');
    return text;
}

main();
