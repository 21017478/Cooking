const fs = require('fs');
const path = require('path');

const SOURCE_FILES = [
    'premium-meals-detailed.md',
    'detailed-recipes.md',
    'tier2-proteins-detailed.md',
    'tier2-pork-detailed.md',
    'tier3-4-sides-detailed.md',
    'vegetarian-mains.md',
    'breakfast-recipes.md',
    'dessert-recipes.md'
];

const OUTPUT_FILE = 'recipes.js';

function main() {
    const allRecipes = [];

    SOURCE_FILES.forEach(file => {
        const filePath = path.join(__dirname, '..', file);
        if (!fs.existsSync(filePath)) {
            console.warn(`Warning: File not found: ${file}`);
            return;
        }

        const content = fs.readFileSync(filePath, 'utf8');
        const recipes = parseFile(content, file);
        allRecipes.push(...recipes);
    });

    const fileContent = `// This file is AUTO-GENERATED by scripts/build-recipes.js
// DO NOT EDIT THIS FILE DIRECTLY. Edit the Markdown files instead.

const recipes = ${JSON.stringify(allRecipes, null, 4)};
`;

    fs.writeFileSync(path.join(__dirname, '..', OUTPUT_FILE), fileContent);
    console.log(`Successfully generated ${OUTPUT_FILE} with ${allRecipes.length} recipes.`);
}

function parseFile(content, filename) {
    // Split by "## " or "### " header
    // We use a regex that matches start of line, 2 or 3 hashes, then space
    const chunks = content.split(/^(?:#{2,3}) /m).slice(1);

    console.log(`Processing ${filename}: Found ${chunks.length} recipe chunks`);

    return chunks.map((chunk, index) => {
        // We pass the chunk directly. The title is the first line.
        const recipe = parseRecipe(chunk, filename);
        if (recipe) {
            console.log(`  Recipe ${index + 1}: ${recipe.name} (ID: ${recipe.id})`);
            return recipe;
        }
        return null;
    }).filter(r => r !== null);
}

function parseRecipe(chunk, filename) {
    const lines = chunk.split('\n');
    const titleLine = lines[0].trim();

    let id = '';
    let name = '';
    let emoji = 'ü•ò';

    // Regex to handle:
    // üçÑ RECIPE V-001: Name
    // PREMIUM MEAL 012: Name
    // MEAL 012: Name

    // The chunk split consumed the "### " or "## ", so titleLine is what follows.

    const titleMatch = titleLine.match(/(?:(.*?)\s+)?(?:PREMIUM\s+)?(?:RECIPE|MEAL)\s*([A-Za-z0-9-]+):\s*(.*)/i);

    if (titleMatch) {
        const capturedEmoji = titleMatch[1] ? titleMatch[1].trim() : '';
        // Simple check to avoid capturing text as emoji (emojis are usually 1-2 chars, text is longer)
        // But some emojis are composite. Let's assume if it's short it's an emoji.
        if (capturedEmoji && capturedEmoji.length < 5) emoji = capturedEmoji;

        id = titleMatch[2].trim();
        name = titleMatch[3].trim();
    } else {
        // Fallback
        name = titleLine;
        id = name.replace(/[^a-z0-9]/gi, '-').toLowerCase();
    }

    id = id.toLowerCase();

    let category = 'Main';
    let type = 'Standard';

    const metaLine = lines.find(l => l.includes('**Category:**'));
    if (metaLine) {
        const catMatch = metaLine.match(/\*\*Category:\*\*\s*(.*?)\s*\|/);
        const typeMatch = metaLine.match(/\*\*Type:\*\*\s*(.*)/);
        if (catMatch) category = catMatch[1].trim();
        if (typeMatch) type = typeMatch[1].trim();
    } else if (filename.includes('premium')) {
        type = 'Premium';
        category = 'Premium';
    } else if (filename.includes('vegetarian')) {
        category = 'Vegetarian';
    } else if (filename.includes('breakfast')) {
        category = 'Breakfast';
    } else if (filename.includes('dessert')) {
        category = 'Dessert';
    }

    let prepTime = 'N/A';
    let cookTime = 'N/A';
    let totalTime = 'N/A';

    const timeSection = extractSection(chunk, 'Time Requirements');
    if (timeSection) {
        const prepMatch = timeSection.match(/\*\*Prep Time:\*\*\s*(.*)/);
        const cookMatch = timeSection.match(/\*\*Cook Time:\*\*\s*(.*)/);
        const totalMatch = timeSection.match(/\*\*Total Time:\*\*\s*(.*)/);

        if (prepMatch) prepTime = prepMatch[1].trim();
        if (cookMatch) cookTime = cookMatch[1].trim();
        if (totalMatch) totalTime = totalMatch[1].trim();
    }

    const htmlContent = convertMarkdownToHtml(chunk);

    return {
        id,
        name,
        category: category.toLowerCase(),
        type: type.toLowerCase(),
        isPremium: type.toLowerCase().includes('premium'),
        image: emoji,
        description: extractDescription(chunk),
        prepTime,
        cookTime,
        totalTime,
        content: htmlContent
    };
}

function extractSection(markdown, sectionName) {
    const regex = new RegExp(`####\\s+${sectionName}([\\s\\S]*?)(?=####|$)`, 'i');
    const match = markdown.match(regex);
    return match ? match[1].trim() : null;
}

function extractDescription(markdown) {
    const whySpecial = extractSection(markdown, 'Why This Meal is Special') ||
        extractSection(markdown, 'Why Vacuum Sealing Makes It Special');

    if (whySpecial) {
        return whySpecial.split('\n')[0].replace(/\*\*/g, '');
    }

    return "A delicious vacuum sealer recipe.";
}

function convertMarkdownToHtml(markdown) {
    return processLinesToHtml(markdown);
}

function processLinesToHtml(markdown) {
    const lines = markdown.split('\n');
    let html = '';
    let inList = false;
    let listType = null;

    lines.forEach((line, index) => {
        line = line.trim();

        // Skip Title (first line is title)
        if (index === 0) return;

        if (line.startsWith('**Category:**')) return;
        if (line === '---') return;

        if (line.startsWith('#### ')) {
            if (inList) { html += `</${listType}>\n`; inList = false; }
            html += `<h3>${line.replace('#### ', '')}</h3>\n`;
            return;
        }

        const isUl = line.startsWith('- ');
        const isOl = /^\d+\.\s/.test(line);

        if (isUl || isOl) {
            const currentType = isUl ? 'ul' : 'ol';

            if (!inList) {
                inList = true;
                listType = currentType;
                html += `<${listType}>\n`;
            } else if (listType !== currentType) {
                html += `</${listType}>\n<${currentType}>\n`;
                listType = currentType;
            }

            const content = line.replace(/^(- |\d+\.\s)/, '');
            html += `  <li>${formatInline(content)}</li>\n`;
        } else {
            if (inList) {
                html += `</${listType}>\n`;
                inList = false;
            }

            if (line.length > 0) {
                if (line.startsWith('**') && line.endsWith('**') && line.length < 50) {
                    html += `<h4>${line.replace(/\*\*/g, '')}</h4>\n`;
                } else {
                    html += `<p>${formatInline(line)}</p>\n`;
                }
            }
        }
    });

    if (inList) html += `</${listType}>\n`;

    return html;
}

function formatInline(text) {
    text = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
    text = text.replace(/\*(.*?)\*/g, '<em>$1</em>');
    return text;
}

main();
